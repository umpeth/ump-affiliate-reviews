type Storefront @entity {
  id: Bytes! # storefront address
  storefrontAddress: Bytes! @index(unique: true)
  owner: Bytes!
  erc1155Token: Bytes!
  arbiter: Bytes!
  escrowFactory: Bytes!
  minSettleTime: BigInt!
  settleDeadline: BigInt!
  ready: Boolean!
  seaport: Bytes!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  listings: [TokenListing!]! @derivedFrom(field: "storefront")
  orders: [Order!]! @derivedFrom(field: "storefront")
  isAffiliateEnabled: Boolean!
  affiliateVerifier: Bytes
  
  # Contract metadata fields
  contractURI: String
  contractMetadata: ERC1155ContractMetadata
  
  # Review-related fields
  totalRating: BigInt!
  reviewCount: BigInt!
  reviews: [Review!]! @derivedFrom(field: "storefront")
}

type TokenListing @entity {
  id: ID!
  storefront: Storefront!
  tokenId: BigInt!
  price: BigInt!
  paymentToken: Bytes!
  listingTime: BigInt!
  active: Boolean!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  lastUpdateAt: BigInt!
  lastUpdateTx: Bytes!
  tokenURI: String
  contractURI: String  
  tokenMetadata: ERC1155TokenMetadata
  contractMetadata: ERC1155ContractMetadata
  affiliateFee: Int! # In basis points (0-10000)
}

type Order @entity {
  id: Bytes! # transaction hash
  buyer: Bytes!
  seller: Bytes! 
  storefront: Storefront!
  tokenId: BigInt!
  amount: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Reference to escrow contract
  escrowContract: Bytes
  
  # Reference to sale attestations - changed from singular to plural
  saleAttestations: [SaleAttestation!]! @derivedFrom(field: "order")
  
  # Store latest attestation timestamp for easier querying
  latestAttestationTimestamp: BigInt
  
  # Store reference to the latest attestation ID
  latestAttestationId: Bytes
  
  # Affiliate-related fields
  affiliate: Bytes
  affiliateShare: BigInt
}

type SaleAttestation @entity {
  id: Bytes! # attestation UID
  transactionHash: Bytes! # references Order.id
  attestationTxHash: Bytes! # hash of the attestation transaction
  order: Order! 
  buyer: Bytes! # From sale event parameters
  seller: Bytes! # From sale event parameters
  storefront: Bytes!
  escrowContract: OrderEscrow! # Reference to OrderEscrow entity
  storefrontContract: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  attestationFee: BigInt # Fee paid for the attestation
  reviews: [Review!]! @derivedFrom(field: "saleAttestation")
  
  # Add a flag to identify the most recent attestation for an order
  isLatest: Boolean!
}

type Review @entity(immutable: true) {
  id: Bytes! # attestation UID 
  saleAttestation: SaleAttestation!
  reviewer: Bytes!
  reviewType: String! # "buyer" or "seller"
  storefront: Storefront! # For easy querying of storefront reviews
  overallRating: Int! # 0-5
  qualityRating: Int! # 0-5
  communicationRating: Int! # 0-5
  deliveryRating: Int! # 0-5
  packagingRating: Int! # 0-5
  asDescribed: Boolean!
  reviewText: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  attestationTxHash: Bytes! # hash of the review attestation transaction
  transactionHash: Bytes! # hash of the original sale transaction
}

type OrderEscrow @entity {
  id: ID!
  escrowAddress: Bytes!
  payee: Bytes!
  
  # Can be either a storefront or auction house address
  sourceAddress: Bytes!
  
  # Type of source (STOREFRONT or AUCTION_HOUSE)
  sourceType: EscrowSourceType!
  
  arbiter: Bytes!
  isDisputed: Boolean!
  isRefunded: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  payments: [OrderPayment!]! @derivedFrom(field: "escrow")
  settledEvents: [Settled!]! @derivedFrom(field: "escrow")
  refundedEvents: [Refunded!]! @derivedFrom(field: "escrow")
  disputedEvents: [Disputed!]! @derivedFrom(field: "escrow")
  disputeRemovedEvents: [DisputeRemoved!]! @derivedFrom(field: "escrow")
  disputeResolvedEvents: [DisputeResolved!]! @derivedFrom(field: "escrow")
  escapeAddressSetEvents: [EscapeAddressSet!]! @derivedFrom(field: "escrow")
  escapedEvents: [Escaped!]! @derivedFrom(field: "escrow")
  arbiterChangeEvents: [ArbiterChange!]! @derivedFrom(field: "escrow")
  affiliate: Bytes
  affiliateShare: BigInt
  
  # Reference to order or auction (only one will be non-null)
  order: Order
  auction: Auction
  
  # Multiple sale attestations for this escrow contract
  attestations: [SaleAttestation!]! @derivedFrom(field: "escrowContract")
}

enum EscrowSourceType {
  STOREFRONT
  AUCTION_HOUSE
}

type OrderPayment @entity {
  id: ID!
  escrow: OrderEscrow!
  payer: Bytes!
  settleDeadline: BigInt!
  orderFulfilled: OrderFulfilled
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ArbiterChange @entity {
  id: ID!
  escrow: OrderEscrow!
  oldArbiter: Bytes!
  proposedArbiter: Bytes!
  newArbiter: Bytes
  approved: Boolean!
  approver: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Settled @entity {
  id: ID!
  escrow: OrderEscrow!
  to: Bytes!
  token: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Refunded @entity {
  id: ID!
  escrow: OrderEscrow!
  to: Bytes!
  token: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Disputed @entity {
  id: ID!
  escrow: OrderEscrow!
  disputeInitiator: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DisputeRemoved @entity {
  id: ID!
  escrow: OrderEscrow!
  disputeRemover: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DisputeResolved @entity {
  id: ID!
  escrow: OrderEscrow!
  resolver: Bytes!
  settled: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EscapeAddressSet @entity {
  id: ID!
  escrow: OrderEscrow!
  escapeAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Escaped @entity {
  id: ID!
  escrow: OrderEscrow!
  to: Bytes!
  token: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ERC1155ContractMetadata @entity {
  id: ID!
  name: String
  description: String
  image: String
  externalLink: String
  rawJson: String!
}

type ERC1155TokenMetadata @entity {
  id: ID!
  rawJson: String!
  rawEncodedJson: String!
}

type OrderFulfilled @entity {
  id: ID!
  orderHash: Bytes!
  offerer: Bytes!
  zone: Bytes!
  recipient: Bytes!
  offer: [OfferItem!]!
  consideration: [ConsiderationItem!]!
  payment: OrderPayment
  erc1155ContractURI: String
  erc1155TokenURI: String
  contractMetadata: ERC1155ContractMetadata
  tokenMetadata: ERC1155TokenMetadata
  encryptedData: Bytes
  ephemeralPublicKey: Bytes
  iv: Bytes
  verificationHash: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  affiliate: Bytes
  affiliateShare: BigInt
}

type OfferItem @entity {
  id: ID!
  orderFulfilled: OrderFulfilled!
  itemType: BigInt!
  token: Bytes!
  identifier: BigInt!
  amount: BigInt!
}

type ConsiderationItem @entity {
  id: ID!
  orderFulfilled: OrderFulfilled!
  itemType: BigInt!
  token: Bytes!
  identifier: BigInt!
  amount: BigInt!
  recipient: Bytes!
}

# Curation-related entities
type CurationStorefront @entity {
  id: ID!                         # Token ID
  name: String!
  description: String!
  owner: Bytes!
  paymentAddress: Bytes!
  tokenURI: String
  listings: [CurationListing!]! @derivedFrom(field: "curation")
  activeCurators: [Curator!]! @derivedFrom(field: "curation")
  curatorHistory: [CuratorAction!]! @derivedFrom(field: "curation")
  createdAt: BigInt!
  createdTxHash: Bytes!
}

type Curator @entity {
  id: ID!                         # curationId + "-" + curator address
  curation: CurationStorefront!
  curator: Bytes!
  isActive: Boolean!
  addedAt: BigInt!
  addedTxHash: Bytes!
  removedAt: BigInt
  removedTxHash: Bytes
  actions: [CuratorAction!]! @derivedFrom(field: "curator")
}

type CuratorAction @entity {
  id: ID!                         # transaction hash + "-" + log index
  curation: CurationStorefront!
  curator: Curator!
  actionType: String!             # "ADDED" or "REMOVED"
  timestamp: BigInt!
  transactionHash: Bytes!
}

type CurationListing @entity {
  id: ID!                         # curationId + "-" + listingId
  curation: CurationStorefront!
  listingId: BigInt!
  storefront: Bytes!              # Storefront address
  tokenId: BigInt!                # Original token ID
  active: Boolean!
  createdAt: BigInt!
  createdTxHash: Bytes!
  lastUpdatedAt: BigInt
  lastUpdatedTxHash: Bytes
  
  # Mirrored token listing data for easier queries
  price: BigInt
  paymentToken: Bytes
  affiliateFee: Int
  tokenURI: String
  contractURI: String
  tokenMetadata: ERC1155TokenMetadata
  contractMetadata: ERC1155ContractMetadata
  erc1155Token: Bytes
}

# AUCTION HOUSE ENTITIES

type AuctionHouse @entity {
  id: Bytes! # auction house address
  auctionHouseAddress: Bytes! @index(unique: true)
  owner: Bytes!
  name: String!
  image: String!
  description: String!
  settlementDeadline: BigInt!
  version: String!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  
  # Additional metadata fields from enhanced event
  contractURI: String
  symbol: String
  
  # Relationships
  auctions: [Auction!]! @derivedFrom(field: "auctionHouse")
  
  # Metadata
  lastUpdatedAt: BigInt
  lastUpdatedTx: Bytes
}

type Auction @entity {
  id: ID! # auctionHouse address + "-" + auctionId
  auctionId: BigInt!
  auctionHouse: AuctionHouse!
  tokenId: BigInt!
  tokenContract: Bytes!
  tokenReference: AuctionItemERC721Token # Add this reference for proper derivation
  highestBid: BigInt!
  duration: BigInt!
  startTime: BigInt!
  endTime: BigInt!
  reservePrice: BigInt!
  affiliateFee: Int! # In basis points (0-10000)
  auctionOwner: Bytes!
  arbiter: Bytes!
  auctionCurrency: Bytes! # address(0) for ETH
  minBidIncrementBps: Int!
  isPremiumAuction: Boolean!
  premiumBps: Int!
  timeExtension: BigInt!
  paymentAmount: BigInt!
  
  # Current state
  currentBidder: Bytes
  currentAffiliate: Bytes
  highestBidAmount: BigInt!
  escrowAddress: Bytes
  status: AuctionStatus!
  tokenMetadata: AuctionItemERC721Metadata
  currentWinningBid: Bid
  
  # Relationships
  bids: [Bid!]! @derivedFrom(field: "auction")
  encryptedMessages: [EncryptedMessage!]! @derivedFrom(field: "auction")
  premiumPayments: [PremiumPayment!]! @derivedFrom(field: "auction")
  escrow: OrderEscrow
  
  # Analytics
  totalBidCount: Int!
  totalPremiumPaid: BigInt!
  wasExtended: Boolean!
  extensionCount: Int!
  
  # Timestamps
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
  endedAt: BigInt
  endedAtBlock: BigInt
  endedTx: Bytes
}

type Bid @entity {
  id: ID! # transaction hash + "-" + log index
  auction: Auction!
  bidder: Bytes!
  amount: BigInt!
  affiliate: Bytes
  isWinningBid: Boolean!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  
  # Related entities
  encryptedMessage: EncryptedMessage
}

type EncryptedMessage @entity {
  id: ID! # transaction hash + "-" + log index
  auction: Auction!
  bidder: Bytes!
  encryptedData: Bytes
  ephemeralPublicKey: Bytes
  iv: Bytes
  verificationHash: Bytes
  isFinal: Boolean!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type PremiumPayment @entity {
  id: ID! # transaction hash + "-" + log index
  auction: Auction!
  outbidUser: Bytes!
  newBidder: Bytes!
  originalBid: BigInt!
  premiumAmount: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type AuctionItemERC721 @entity {
  id: Bytes! # token contract address
  tokenAddress: Bytes! @index(unique: true)
  name: String!
  symbol: String!
  contractURI: String
  owner: Bytes!
  
  # Tokens
  tokens: [AuctionItemERC721Token!]! @derivedFrom(field: "contract")
  
  # Metadata
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  lastUpdatedAt: BigInt
  lastUpdatedTx: Bytes
}

type AuctionItemERC721Token @entity {
  id: ID! # contract address + "-" + tokenId
  contract: AuctionItemERC721!
  tokenId: BigInt!
  owner: Bytes!
  
  # Metadata
  metadata: AuctionItemERC721Metadata
  
  # Auction history
  auctions: [Auction!]! @derivedFrom(field: "tokenReference")
  
  # Timestamps
  createdAt: BigInt!
  createdAtBlock: BigInt!
  creationTx: Bytes!
  lastTransferredAt: BigInt
  lastTransferredTx: Bytes
}

type AuctionItemERC721Metadata @entity {
  id: ID! # hash of metadata
  name: String
  description: String
  image: String
  termsOfService: String
  supplementalImages: [String!]
  rawJson: String!
}

enum AuctionStatus {
  CREATED
  ACTIVE
  COMPLETED
  CANCELLED
}

type _Schema_ @fulltext(
  name: "reviewSearch"
  language: en
  algorithm: rank
  include: [
    {
      entity: "Review",
      fields: [
        { name: "reviewText" }
      ]
    }
  ]
)
